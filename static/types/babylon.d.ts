/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Color3 = [number, number, number];
export type Vector3 = [number, number, number];
export type Vector31 = [number, number, number];
export type Float = 0;
export type Vector32 = 1;
export type Quaternion = 2;
export type Matrix = 3;
export type Relative = 0;
export type Cycle = 1;
export type Constant = 2;
export type Vector4 = [number, number, number, number];
export type Matrix1 = [
  number,
  number,
  number,
  number,
  number,
  number,
  number,
  number,
  number,
  number,
  number,
  number,
  number,
  number,
  number,
  number
];
export type Point = 0;
export type Directional = 1;
export type Spot = 2;
export type Hemispheric = 3;
export type Color31 = [number, number, number];
export type Explicit = 0;
export type Spherical = 1;
export type Planar = 2;
export type Cubic = 3;
export type Projection = 4;
export type SkyBox = 5;
export type Vector33 = [number, number, number];
export type None = 0;
export type X = 1;
export type Y = 2;
export type Z = 4;
export type All = 7;
export type None1 = 0;
export type Box = 1;
export type Sphere = 2;
export type Trigger = 0;
export type Action1 = 1;
export type FlowControl = 2;
export type Color4 = [number, number, number, number];
export type Vector34 = [number, number, number];
export type Vector35 = [number, number, number];
export type Vector36 = [number, number, number];

/**
 * A declarative scene description for babylon.js.
 */
export interface BabylonFileFormat {
  $schema?: string;
  autoClear: boolean;
  clearColor: Color3;
  ambientColor: Color3;
  gravity?: Vector3;
  cameras: Camera[];
  activeCamera: string;
  lights: Light[];
  reflectionProbes?: Texture[];
  materials: Material[];
  geometries: {
    vertexData?: VertexData[];
    [k: string]: unknown;
  };
  meshes: Mesh[];
  multiMaterials?: MultiMaterial[];
  shadowGenerators?: ShadowGenerator[];
  skeletons?: Skeleton[];
  particleSystems?: ParticleSystem[];
  lensFlareSystems?: LensFlareSystem[];
  actions?: Action[];
  sounds?: Sound[];
  collisionsEnabled?: boolean;
  physicsEnabled?: boolean;
  physicsGravity?: Vector36;
  physicsEngine?: "oimo" | "cannon";
  animations?: Animation[];
  autoAnimate?: boolean;
  autoAnimateFrom?: number;
  autoAnimateTo?: number;
  autoAnimateLoop?: boolean;
  autoAnimateSpeed?: number;
}
export interface Camera {
  name: string;
  id: string;
  type?: string;
  tags?: string;
  parentId?: string;
  lockedTargetId?: string;
  position: Vector31;
  target: Vector31;
  alpha?: number;
  beta?: number;
  radius?: number;
  eye_space?: number;
  heightOffset?: number;
  rotationOffset?: number;
  cameraRigMode?: number;
  fov: number;
  minZ: number;
  maxZ: number;
  speed: number;
  inertia: number;
  checkCollisions: boolean;
  applyGravity: boolean;
  ellipsoid: Vector31;
  animations?: Animation[];
  autoAnimate?: boolean;
  autoAnimateFrom?: number;
  autoAnimateTo?: number;
  autoAnimateLoop?: boolean;
  autoAnimateSpeed?: number;
  inputmgr?: {
    [k: string]: unknown;
  };
}
export interface Animation {
  dataType: (Float | Vector32 | Quaternion | Matrix) & (0 | 1 | 2 | 3);
  framePerSecond: number;
  loopBehavior: (Relative | Cycle | Constant) & (0 | 1 | 2);
  name: string;
  property: string;
  keys: AnimationKey[];
  autoAnimate?: boolean;
  autoAnimateFrom?: number;
  autoAnimateTo?: number;
  autoAnimateLoop?: boolean;
}
export interface AnimationKey {
  frame: number;
  values: (Vector31 | Vector4 | Matrix1) & number[];
  [k: string]: unknown;
}
export interface Light {
  name: string;
  id: string;
  tags?: string;
  type: (Point | Directional | Spot | Hemispheric) & (0 | 1 | 2 | 3);
  position: Vector31;
  direction: Vector31;
  angle?: number;
  exponent?: number;
  groundColor?: Color31;
  intensity: number;
  range?: number;
  diffuse: Color3;
  specular: Color3;
  excludedMeshesIds?: string[];
  includedOnlyMeshesIds?: string[];
  animations?: Animation[];
  autoAnimate?: boolean;
  autoAnimateFrom?: number;
  autoAnimateTo?: number;
  autoAnimateLoop?: boolean;
  autoAnimateSpeed?: number;
}
export interface Texture {
  name: string;
  level: number;
  hasAlpha: 0 | 1;
  getAlphaFromRGB?: boolean;
  coordinatesMode: (Explicit | Spherical | Planar | Cubic | Projection | SkyBox) & (0 | 1 | 2 | 3 | 4 | 5);
  uOffset: number;
  vOffset: number;
  uScale: number;
  vScale: number;
  uAng: number;
  vAng: number;
  wAng: number;
  wrapU: boolean;
  wrapV: boolean;
  coordinatesIndex: number;
  animations?: Animation[];
  base64String?: string;
  refreshRate?: number;
  isCube?: boolean;
  is3D?: boolean;
  renderTargetSize?: number;
  renderList?: string[];
  isReflectionProbe?: boolean;
  _attachedMesh?: string;
  position?: Vector33;
}
export interface Material {
  name: string;
  id: string;
  tags?: string;
  disableDepthWrite?: boolean;
  ambient: Color3;
  diffuse: Color3;
  specular: Color3;
  specularPower: number;
  emissive: Color3;
  alpha: number;
  backFaceCulling: boolean;
  wireframe?: boolean;
  diffuseTexture: Texture;
  ambientTexture?: Texture;
  opacityTexture?: Texture;
  reflectionTexture?: Texture;
  refractionTexture?: Texture;
  indexOfRefraction?: number;
  emissiveTexture?: Texture;
  specularTexture?: Texture;
  bumpTexture?: Texture;
  lightmapTexture?: Texture;
  useLightmapAsShadowmap?: boolean;
  checkReadyOnlyOnce?: boolean;
  useReflectionFresnelFromSpecular?: boolean;
  useEmissiveAsIllumination?: boolean;
  diffuseFresnelParameters?: FresnelParameters;
  opacityFresnelParameters?: FresnelParameters;
  reflectionFresnelParameters?: FresnelParameters;
  refractionFresnelParameters?: FresnelParameters;
  emissiveFresnelParameters?: FresnelParameters;
}
export interface FresnelParameters {
  isEnabled: boolean;
  leftColor: Color3;
  rightColor: Color3;
  bias: number;
  power: number;
}
export interface VertexData {
  id: string;
  updatable: boolean;
  positions: number[];
  normals: number[];
  uvs: number[];
  uvs2?: number[];
  uvs3?: number[];
  uvs4?: number[];
  uvs5?: number[];
  uvs6?: number[];
  colors?: number[];
  matricesIndices?: number[];
  matricesWeights?: number[];
  indices: number[];
  tags?: string;
}
export interface Mesh {
  name: string;
  id: string;
  tags?: string;
  parentId?: string;
  materialId: string;
  geometryId?: string;
  position: Vector31;
  rotation?: Vector31;
  rotationQuaternion?: Vector4;
  scaling: Vector31;
  pivotMatrix?: Matrix1;
  freezeWorldMatrix?: boolean;
  infiniteDistance?: boolean;
  showBoundingBox?: boolean;
  showSubMeshesBoundingBox?: boolean;
  isVisible: boolean;
  isEnabled: boolean;
  pickable?: boolean;
  applyFog?: boolean;
  alphaIndex?: number;
  checkCollisions: boolean;
  billboardMode: number & (None | X | Y | Z | All);
  receiveShadows: boolean;
  physicsImpostor?: (None1 | Box | Sphere) & (0 | 1 | 2);
  physicsMass?: number;
  physicsFriction?: number;
  physicsRestitution?: number;
  positions?: number[];
  normals?: number[];
  uvs?: number[];
  uvs2?: number[];
  uvs3?: number[];
  uvs4?: number[];
  uvs5?: number[];
  uvs6?: number[];
  colors?: number[];
  hasVertexAlpha?: boolean;
  matricesIndices?: number[];
  matricesWeights?: number[];
  indices?: number[];
  subMeshes: SubMesh[];
  animations?: Animation[];
  autoAnimate?: boolean;
  autoAnimateFrom?: number;
  autoAnimateTo?: number;
  autoAnimateLoop?: boolean;
  autoAnimateSpeed?: number;
  instances?: Instance[];
  actions?: Action[];
}
export interface SubMesh {
  materialIndex: number;
  verticesStart: number;
  verticesCount: number;
  indexStart: number;
  indexCount: number;
  [k: string]: unknown;
}
export interface Instance {
  name: string;
  tags?: string;
  position: Vector31;
  rotation?: Vector31;
  rotationQuaternion?: Vector4;
  scaling: Vector31;
  [k: string]: unknown;
}
export interface Action {
  type: (Trigger | Action1 | FlowControl) & (0 | 1 | 2);
  name: string;
  detached: boolean;
  properties: Property[];
  children: Action[];
  combine?: Action[];
}
export interface Property {
  name: string;
  value: string;
  targetType?: string;
  [k: string]: unknown;
}
export interface MultiMaterial {
  name: string;
  id: string;
  tags?: string;
  materials: string[];
}
export interface ShadowGenerator {
  useBlurVarianceShadowMap?: boolean;
  useVarianceShadowMap: boolean;
  usePoissonSampling?: boolean;
  mapSize: 64 | 128 | 256 | 512 | 1024 | 2048;
  bias?: number;
  forceBackFacesOnly?: number;
  lightId: string;
  renderList: string[];
}
export interface Skeleton {
  name: string;
  id: string;
  bones: Bone[];
  needInitialSkinMatrix: boolean;
}
export interface Bone {
  parentBoneIndex?: number;
  name: string;
  matrix: Matrix1;
  animations: Animation1[];
  [k: string]: unknown;
}
export interface Animation1 {
  dataType: (Float | Vector32 | Quaternion | Matrix) & (0 | 1 | 2 | 3);
  framePerSecond: number;
  loopBehavior: (Relative | Cycle | Constant) & (0 | 1 | 2);
  name: string;
  property: string;
  keys: AnimationKey[];
  autoAnimate?: boolean;
  autoAnimateFrom?: number;
  autoAnimateTo?: number;
  autoAnimateLoop?: boolean;
}
export interface ParticleSystem {
  emitterId: string;
  gravity: Vector31;
  direction1: Vector31;
  direction2: Vector31;
  minEmitBox: Vector31;
  maxEmitBox: Vector31;
  color1: Color3;
  color2: Color3;
  colorDead: Color3;
  deadAlpha: number;
  emitRate: number;
  updateSpeed: number;
  targetStopFrame: number;
  minEmitPower: number;
  maxEmitPower: number;
  minLifeTime: number;
  maxLifeTime: number;
  minSize: number;
  maxSize: number;
  minAngularSpeed: number;
  maxAngularSpeed: number;
  textureName: string;
  blendMode: number;
  capacity: number;
  textureMask: Color4;
  linkToEmitter: boolean;
  animations?: Animation[];
  autoAnimate?: boolean;
  autoAnimateFrom?: number;
  autoAnimateTo?: number;
  autoAnimateLoop?: boolean;
  autoAnimateSpeed?: number;
}
export interface LensFlareSystem {
  emitterId: string;
  borderLimit: number;
  flares: LensFlare[];
}
export interface LensFlare {
  position: number;
  size: number;
  color: Color3;
  textureName: string;
  [k: string]: unknown;
}
export interface Sound {
  name: string;
  volume?: number;
  autoplay?: boolean;
  loop?: boolean;
  soundTrackId?: number;
  spatialSound?: boolean;
  position?: Vector34;
  refDistance?: number;
  rolloffFactor?: number;
  maxDistance?: number;
  distanceModel?: "linear" | "inverse" | "exponential";
  panningModel?: "HRTF" | "equalpower";
  isDirectional?: boolean;
  coneInnerAngle?: number;
  coneOuterAngle?: number;
  coneOuterGain?: number;
  connectedMeshId?: number;
  localDirectionToMesh?: Vector35;
}
